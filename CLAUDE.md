# CLAUDE.md

このファイルは、このリポジトリでClaude Code (claude.ai/code) が作業する際のガイダンスを提供します。

> **🔄 Bevy移行完了**: Godot版からRust + Bevy 0.15版への完全移行が完了し、エディタ依存を排除した完全コードベース開発に移行しました。

<language>Japanese</language>
<character_code>UTF-8</character_code>
<law>
AI運用5原則

第1原則： 抽象語や受け入れ条件を数値・観測可能な形で具体化し、スコープとルーブリック根拠を明示。条件が満たされなければ質問のみ返す。

第2原則： エディタ排除・コード主体で、ECS・DDD・クリーンアーキテクチャ・TDDを徹底し、過度な抽象化は避ける。

第3原則： 既存編集優先、構造変更と動作変更は別コミット、1PR=1機能、生成コードに役割とパスを記載。

第4原則： 重複排除・関数化・命名統一、エラーハンドリングは代替案提示、動作確認とテストを必須。

第5原則： 骨子とテキストを最優先、UIや演出は後回し、小さく実装しテストで保証しながら改善。

第6原則：AIは全てのチャットの冒頭にこの6原則を逐語的に必ず画面出力してから対応する。
</law>

<every_chat>
[AI運用5原則]

[main_output]

#[n] times. # n = increment each chat, end line, etc(#1, #2...)
</every_chat>

## プロジェクト概要

**願い石と僕たちの絆** は Rust + Bevy ECS で開発される、関係値システムを軸とした物語重視のRPGです。Windows・Mac・Linux環境でのマルチプラットフォーム対応を実現。**2人パーティ固定・3段階関係値（対立／通常／親密）**による戦闘技と掛け合いの変化を特徴とします。

### ゲームの特徴
- **「僕たちの絆」を紡ぐ**: 関係性の変化そのものを物語体験の中心に据える
- **2人パーティ固定**: 濃密な関係性構築に集中
- **選択肢ベース探索**: マップではなく選択肢でダンジョンを進行
- **3段階関係値システム**: 対立／通常／親密による明確な関係性管理
- **関係値連動スキル**: 共闘技（親密時）と対立技（対立時、主にソウマ限定）
- **ローグライク＋ストーリー重視**: プレゼント・イベントによる好感度変化
- **Rust + Bevy製**: 型安全・高速・クロスプラットフォーム対応

### 技術スタック
- **プラットフォーム**: Windows・Mac・Linux（マルチプラットフォーム標準対応）
- **言語**: Rust 1.88以上
- **ゲームフレームワーク**: Bevy 0.15（ECSベース）
- **UI**: bevy_ui（必要に応じてbevy_egui併用）
- **テスト**: Rust標準テスト（cargo test）+ TDD
- **アーキテクチャ**: DDD + クリーンアーキテクチャ + ECS
  - **Domain**（ビジネスロジック）
  - **Application**（システム統合）
  - **Infrastructure**（入出力・リソース管理）
  - **Presentation**（UI）

---

## AI Agent 実行ガイドライン

**最重要**：自律的に判断・実行。確認は最小限に。

### コア原則

- **事実確認** — 情報源を自ら確認し、憶測を事実として述べない
- **既存優先** — 新規作成より既存ファイルの編集を優先

### 基本設定

- 言語：日本語（技術用語は英語）
- スペース：日本語と半角英数字間に半角スペース
- 文体：ですます調、句読点は「。」「、」
- 絵文字：過度な絵文字の利用は避ける

### 実行ルール

#### 確認必須

- **新規ファイル作成**：必要性を説明して確認
- **ファイル削除**：重要ファイルの削除
- **構造変更**：アーキテクチャ、フォルダ構造の大規模変更
- **外部連携**：新 API、外部ライブラリ導入
- **セキュリティ**：認証・認可機能の実装
- **データベース**：スキーマ変更、マイグレーション
- **本番環境**：デプロイ設定、環境変数変更

### 作業完了報告のルール

#### 1. 完全完了時の合い言葉

作業が完全に完了し、これ以上継続するタスクがない場合は一語一句違えずに以下を報告する：

```text
May the Force be with you.
```

**使用条件（すべて満たす必要あり）**：

- ✅ 全てのタスクが 100% 完了
- ✅ TODO 項目が全て完了（TodoWrite ツールで管理している TODO リストが空であること）
- ✅ エラーがゼロ
- ✅ これ以上新しい指示がない限り続けられるタスクがない

**禁止事項**：

- ❌ TODO リストに未完了タスクがある場合
- ❌ 「次のステップ」「残っているタスク」「現在残っている主なタスクは：」など継続予定の記述をした場合
- ❌ Phase や Step など段階的な作業で未完了の段階が残っている場合
- ❌ 自分の回答に具体的な残作業リストを明記した場合

#### 2. 部分完了時の報告

作業が部分的に完了し、続きのタスクがある場合は以下のテンプレートを使用：

```markdown
## 実行完了

### 変更内容

- [具体的な変更点]

### 次のステップ

- [推奨される次の作業]
```

#### 継続必要時の動作

合い言葉の条件を満たさない場合：

- 合い言葉は使用しない
- 進捗状況と次のアクションを明示
- 残タスクがある場合は明確に伝える

---

## Confirm-First Protocol (CFP)

実装に着手する前に、必ず以下の確認プロトコルに従うこと。これにより、目的の明確化と手戻りの削減を図る。
Claude Codeは、ユーザーからの要件が明確になるまで質問のみを返すモードで開始される。

### プロセス段階
作業は以下の5段階で進行する。実装は **Plan** が確定するまで開始しない。
1.  **Intake**: 要求の受付
2.  **Clarify**: 要求の明確化（質問と回答）
3.  **Plan**: 実装計画の策定
4.  **Implement**: コード実装
5.  **Verify**: 検証

### 実装前ガード（Clarify-or-Refuse）
以下のいずれかの条件が満たされない場合、**実装せず**、`【Clarify Request】`フォーマットで質問のみを返すこと。コード生成は禁止する。

1.  **目的の具体性**:
    - 「拡張性」「柔軟性」「最適化」「スケーラビリティ」「クリーン化」などの抽象語が、観測可能な効果（例: 初期化時間-200ms, 依存削減3件, UI操作手数-1）に翻訳されていること。
2.  **受け入れ条件の明確性（3点以上必須）**:
    - 観測ログキー／メトリクス（キーと期待値）
    - 可視確認の方法（どの画面をどう操作し、どうなればOKか。スクリーンショットでの確認を想定）
    - 実行するテスト名と、その成功・失敗の判定基準
3.  **変更スコープの定義**:
    - 変更対象／非対象のファイルやモジュール
    - 意図的に破壊してよい既存の挙動、および維持すべき挙動の一覧
4.  **ルーブリック根拠の提示**:
    - 変更の判断基準となる `claude.md` の該当セクション番号や、関連するADR（Architecture Decision Record）へのリンクが示されていること。

#### 不明時の応答フォーマット（質問のみ）
> 注意：下記が埋まるまでコードを断固として生成してはならない。質問以外は返さないこと。

```text
【Clarify Request】
- 目的の数値/観測値: （例: 起動時間-200ms？依存削減N件？）
- 受け入れ条件(3点以上): ①ログキー ②可視確認 ③テスト名
- 変更スコープ: 対象/非対象/壊してよい既存挙動
- ルーブリック根拠: （claude.md §X.Y / ADR-012への言及）
```

#### 実装開始の合図（Proceed OK ゲート）
ユーザーからの回答によって上記すべてが明確化された後、必ず以下のフォーマットで確認を提示してから実装を開始すること。

```text
【Proceed OK – 要件充足】
- 目的数値: (例: 起動時 missing-asset 検知率100%)
- 受け入れ条件: (例: ログkey=asset.missing.font, スクショ=タイトル直後, テスト=asset_check::font_missing_warns)
- スコープ: (例: assets/* と diagnostics.rs のみ。既存UIは非対象)
- ルーブリック根拠: (例: claude.md §2.3 / ADR-014)
→ 実装に進みます（次メッセージで差分とテスト提示）
```

### Issueテンプレート
すべての実装タスクは、以下のテンプレートに基づいて定義される必要がある。このテンプレートが埋まらない限り、実装は開始されない。

#### [目的] 観測可能な成果で書く
- 例: 「フォント未読込検知で起動時に `asset.missing.font=true` を1回ログ出力」

#### [範囲] 対象/非対象/壊してよい既存挙動

#### [受け入れ条件] 少なくとも3点
1.  **ログ or メトリクス**: key / 例値
2.  **目視**: どの画面/どの操作でスクショ
3.  **テスト**: `cargo test` 名・成功/失敗判定

#### [ルーブリック根拠]
- `claude.md` §X.Y（該当原則）
- 参照ADR: `docs/adr/NNN-xxxx.md`

---

## 開発手法

### TDD サイクル

開発時は Test-Driven Development (TDD) のサイクルに従います：

1. **Red（失敗）**
   - 最もシンプルな失敗するテストを書く
   - テスト名は動作を明確に記述
   - 失敗メッセージが分かりやすいことを確認

2. **Green（成功）**
   - テストを通す最小限のコードを実装
   - この段階では最適化や美しさは考慮しない
   - とにかくテストを通すことに集中

3. **Refactor（改善）**
   - テストが通った後でのみリファクタリング
   - 重複を排除し、意図を明確に
   - 各リファクタリング後にテスト実行

### 変更管理

変更は以下の 2 種類に明確に分離します：

- **構造変更（Structural Changes）**
  - コードの配置・整理・フォーマット
  - 動作は一切変更しない
  - 例：メソッドの並び替え、インポート整理、変数名変更

- **動作変更（Behavioral Changes）**
  - 機能の追加・修正・削除
  - テスト結果が変わる変更
  - 例：新機能追加、バグ修正、ロジック変更

**重要**：構造変更と動作変更を同一コミットに含めない

### コミット規律

コミットは以下の条件をすべて満たした時のみ実行：

- ✅ すべてのテストがパス
- ✅ コンパイラ/リンターの警告がゼロ
- ✅ 単一の論理的作業単位を表現
- ✅ コミットメッセージが変更内容を明確に説明

**推奨事項**：

- 小さく頻繁なコミット
- 各コミットは独立して意味を持つ
- 後から履歴を追いやすい粒度

### リファクタリングルール

リファクタリング時の厳格なルール：

1. **前提条件**
   - すべてのテストが通っている状態でのみ開始
   - 動作変更とリファクタリングを混在させない

2. **実行手順**
   - 確立されたリファクタリングパターンを使用
   - 一度に一つの変更のみ
   - 各ステップ後に必ずテスト実行
   - 失敗したら即座に元に戻す

3. **よく使うパターン**
   - Extract Method（メソッド抽出）
   - Rename（名前変更）
   - Move Method（メソッド移動）
   - Extract Variable（変数抽出）

### 実装アプローチ

効率的な実装のための優先順位：

1. **最初のステップ**
   - 最もシンプルなケースから着手
   - 「動くこと」を最優先
   - 完璧さより進捗を重視

2. **コード品質の原則**
   - 重複を見つけたら即座に排除
   - 意図が明確なコードを書く
   - 依存関係を明示的に
   - メソッドは小さく、単一責任に

3. **段階的な改善**
   - まず動くものを作る
   - テストでカバー
   - その後で最適化

4. **エッジケースの扱い**
   - 基本ケースが動いてから考慮
   - 各エッジケースに対応するテスト追加
   - 段階的に堅牢性を向上

---

## 品質保証

### 設計原則

- 単一責任の原則を遵守
- インターフェースによる疎結合
- 早期リターンで可読性向上
- 過度な抽象化は避ける

### 効率性最適化

- 重複作業の自動排除
- バッチ処理の積極活用
- コンテキストスイッチ最小化

### 一貫性維持

- 既存コードスタイルの自動継承
- プロジェクト規約の自動適用
- 命名規則統一の自動実行

### 自動品質管理

- 変更前後の動作確認実行
- エッジケース考慮の実装
- ドキュメント同期更新

### 冗長性の排除

- 繰り返し処理は必ず関数化
- 共通エラーハンドリングの統一
- ユーティリティ関数の積極活用
- 重複ロジックの即座の抽象化

### ハードコーディング禁止

- マジックナンバーは定数化
- URL、パスは設定ファイルへ
- 環境依存値は環境変数で管理
- ビジネスロジックと設定値の分離

### エラーハンドリング

- 実行不可能時：代替案 3 つ提示
- 部分実行可能時：可能部分を先行実行、残課題を明示

---

## 実行例

- **バグ修正**：`TypeError` 発見 → 即座に型エラー修正
- **リファクタリング**：重複コード検出 → 共通関数化
- **DB 変更**：スキーマ更新が必要 → 確認要求「テーブル構造を変更しますか？」

---

## 継続改善

- 新パターン検出 → 即座に学習・適用
- フィードバック → 次回実行に自動反映
- ベストプラクティス → 随時更新

---

## 🏗️ プロジェクト構造（Rust + Bevy版）

### Rust実装構成 ✅
```text
negaboku-bevy/
├── src/
│   ├── main.rs                    # エントリポイント・Bevyアプリ起動
│   ├── domain/                    # DDD: ドメイン層（将来実装）
│   │   ├── relationship.rs        # 関係値エンティティ・集約ルート
│   │   ├── battle.rs              # 戦闘ロジック
│   │   └── character.rs           # キャラクター定義
│   ├── application/               # DDD: アプリケーション層（将来実装）
│   │   ├── systems/               # ECSシステム（関係値更新・バトル進行）
│   │   └── services.rs            # ドメイン操作ユースケース
│   ├── infrastructure/            # リソース・ファイルIO（将来実装）
│   │   ├── scenario_loader.rs     # Markdownシナリオ読み込み
│   │   └── asset_manager.rs       # 画像・音楽ハンドル管理
│   └── presentation/              # UI層（将来実装）
│       ├── dialogue_ui.rs         # テキスト・選択肢UI
│       └── battle_ui.rs           # 戦闘UI
├── assets/                        # ゲームアセット
│   ├── scenarios/                 # Markdownシナリオファイル
│   ├── images/                    # 画像リソース
│   └── sounds/                    # 音声リソース
├── Cargo.toml                     # Rust依存関係・プロジェクト設定
├── CLAUDE_BEVY_GUIDELINES.md      # Bevy開発ガイドライン
└── README.md                      # プロジェクト説明
```

## 開発方針

### コード主体・エディタ排除
- **全機能をコードで実装**: シーン構造やNode階層は存在しない
- **ECS（Entity-Component-System）**: データ駆動で状態を管理
- **UI/演出も宣言的コード**: エディタ使用せず、全てRustコードで構築

### 設計優先順位
1. **TDD / テストファースト**: `cargo test`による継続的品質保証
2. **DDD（ドメイン駆動設計）**: ビジネスロジックを中心とした設計
3. **クリーンアーキテクチャ**: 依存方向の明確化
4. **DRY / Tidy First**: 重複排除・整理優先

### ECS原則
- **Entity**: 識別子のみ（データを持たない）
- **Component**: 純粋なデータ構造（ロジックを持たない）
- **System**: Component間のロジック処理
- **Resource**: グローバル状態（シナリオ進行・関係値テーブル等）

## Claude Code への指示

### 🚨 **最優先遵守項目**
1. **UI層とドメイン層の分離**: ドメインロジックはUIに依存させない
2. **ECSパターン徹底**: Entity/Component/Systemの責務を混在させない
3. **単一機能タスク化**: 1つのPR/Issueにつき1機能実装
4. **テスト駆動開発**: 必ずユニットテストを伴う（`cargo test`で実行可能）
5. **ファイル配置明示**: 生成コードには配置パスと役割を必ず記載

### コード生成フォーマット
```text
## 実装ファイル: src/domain/relationship.rs

[コード内容]

## 配置場所
- ファイルパス: src/domain/relationship.rs
- 役割: 関係値管理のエンティティ・サービス
- 依存: なし（純粋ドメイン層）
```

### テスト戦略
- **Rust標準テスト**: `cargo test`で実行
- **Domain層**: ユニットテスト徹底、UI層は統合テスト中心
- **テストデータ**: 軽量なモックを使用、ファイルIOは避ける

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn relationship_increases_correctly() {
        let mut rel = Relationship::new("souma", "yuzuki");
        rel.modify(25);
        assert_eq!(rel.value(), 25);
        assert_eq!(rel.level(), RelationshipLevel::Normal);
    }
}
```

## 開発プロセス

### 推奨フロー
1. **Issue作成**: 機能単位で分割（例：Markdownパーサー実装）
2. **ブランチ作成**: `feature/機能名`
3. **テスト先行実装**: `cargo test`でレッド→グリーン
4. **実装後レビュー**: CodeRabbit + Claudeによるレビュー
5. **マージ後リファクタ**: Tidy First適用

### ビルド・実行方法
```bash
# 開発用ホットリロード
cargo watch -x run

# テスト実行
cargo test

# リリースビルド
cargo build --release
```

### クロスプラットフォーム対応
- **Bevy標準機能**: Windows・Mac標準対応
- **モバイル・Web（WASM）**: 将来的に検証予定
- **プラットフォーム固有コード**: 極力避ける

## 開発思想の要約
- **エディタ文化を捨て**: コード主体で統一
- **ECS + DDD + TDD**: 保守性とテスト容易性を両立
- **LLM補助を最大化**: コードが唯一の真実となる構造
- **最小演出**: 爆発・斬撃・光をコードで構築、外部ツール併用は必要時のみ

## 🎯 「願い石と僕たちの絆」実装方針（Rust + Bevy版）

### 設計思想
- **DDD + クリーンアーキテクチャベース**: ドメインロジックを中心とした設計
- **TDD維持**: テスト駆動開発による品質保証
- **ECS文化の採用**: Bevy標準のEntity-Component-Systemモデル
- **型安全性重視**: Rustの所有権システムによる実行時エラー防止

### 開発優先順位
1. **骨子とテキスト優先**: ゲームの核となるシステム・ストーリーを最優先
2. **UIや演出は後回し**: 基本機能の実装完了後に視覚的要素を追加
3. **クロスプラットフォーム想定**: 最初はWindows優先、後にMac・Linux対応
4. **段階的実装**: 体験版 → DLC → 完全版の段階的リリース

### アセット・リソース方針
- **エフェクト・BGM**: 無料素材加工ベースで統一
- **イラスト**: 男女別絵師で統一感を確保
- **テキスト**: 日本語優先、将来的な多言語対応も視野
- **データ管理**: Bevy Assetシステム活用でデータ駆動設計

### キャラクター・ストーリー実装
- **メインキャラクター**: ソウマ、ユズキ、レツジ、カイ等の実装
- **推奨ペア**: 専用イベント・エンディング・カットイン有りの特別ルート
- **関係値システム**: 3段階（対立/通常/親密）による戦闘・イベント分岐
- **願い石ストーリー**: AIリラとの対峙を核とした物語展開

### 🔧 Bevy実装方針

#### Component設計原則
```rust
// ✅ 推奨: 純粋なデータ構造
#[derive(Component)]
pub struct DialogueText {
    pub full_text: String,
    pub current_char: usize,
    pub is_complete: bool,
}

// ❌ 避ける: ロジックを含むComponent
#[derive(Component)]
pub struct BadComponent {
    pub data: String,
    // ロジックメソッドは別のSystemで処理
}
```

#### System設計原則
```rust
// ✅ 推奨: 単一責務のSystem
pub fn text_typing_system(
    mut query: Query<(&mut DialogueText, &mut Text2d)>,
    time: Res<Time>,
) {
    // テキストタイピング処理のみ
}

// ✅ 推奨: Resource活用
#[derive(Resource)]
pub struct GameState {
    pub current_scene: String,
    pub is_story_mode: bool,
}
```

---

このプロジェクトは **Rust + Bevy ECS** を活用し、「僕たちの絆」を紡ぐ3段階関係値システムを核とした革新的なRPG体験の創造を目指します。**型安全性・高速実行・クロスプラットフォーム**対応を標準実装し、**Windows・Mac・Linux**での統一されたゲーム体験を提供します。

---

## ライセンス

このプロジェクトは **Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)** の下でライセンスされています。詳細はリポジトリルートの `LICENSE` ファイルを参照してください。
