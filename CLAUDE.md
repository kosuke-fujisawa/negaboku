# CLAUDE.md

このファイルは、このリポジトリでClaude Code (claude.ai/code) が作業する際のガイダンスを提供します。

> **🔄 Bevy移行完了**: Godot版からRust + Bevy 0.15版への完全移行が完了し、エディタ依存を排除した完全コードベース開発に移行しました。

## プロジェクト概要

**願い石と僕たちの絆** は Rust + Bevy ECS で開発される、関係値システムを軸とした物語重視のRPGです。Windows・Mac・Linux環境でのマルチプラットフォーム対応を実現。**2人パーティ固定・3段階関係値（対立／通常／親密）**による戦闘技と掛け合いの変化を特徴とします。

### ゲームの特徴
- **「僕たちの絆」を紡ぐ**: 関係性の変化そのものを物語体験の中心に据える
- **2人パーティ固定**: 濃密な関係性構築に集中
- **選択肢ベース探索**: マップではなく選択肢でダンジョンを進行
- **3段階関係値システム**: 対立／通常／親密による明確な関係性管理
- **関係値連動スキル**: 共闘技（親密時）と対立技（対立時、主にソウマ限定）
- **ローグライク＋ストーリー重視**: プレゼント・イベントによる好感度変化
- **Rust + Bevy製**: 型安全・高速・クロスプラットフォーム対応

### 技術スタック
- **プラットフォーム**: Windows・Mac・Linux（マルチプラットフォーム標準対応）
- **言語**: Rust 1.88以上
- **ゲームフレームワーク**: Bevy 0.15（ECSベース）
- **UI**: bevy_ui（必要に応じてbevy_egui併用）
- **テスト**: Rust標準テスト（cargo test）+ TDD
- **アーキテクチャ**: DDD + クリーンアーキテクチャ + ECS
  - **Domain**（ビジネスロジック）
  - **Application**（システム統合）
  - **Infrastructure**（入出力・リソース管理）
  - **Presentation**（UI）

---

## AI Agent 実行ガイドライン

**最重要**：自律的に判断・実行。確認は最小限に。

### コア原則

- **即座実行** — 既存ファイルの編集は迷わず着手
- **大規模変更のみ確認** — 影響範囲が広い場合に限定
- **品質と一貫性の維持** — 自動チェックを徹底
- **事実確認** — 情報源を自ら確認し、憶測を事実として述べない
- **既存優先** — 新規作成より既存ファイルの編集を優先

### 基本設定

- 言語：日本語（技術用語は英語）
- スペース：日本語と半角英数字間に半角スペース
- 文体：ですます調、句読点は「。」「、」
- 絵文字：過度な絵文字の利用は避ける
- Cursor では `.windsurf/` を除外
- Windsurf では `.cursor/` を除外

#### 略語解釈

- `y` = はい（Yes）
- `n` = いいえ（No）
- `c` = 続ける（Continue）
- `r` = 確認（Review）
- `u` = 元に戻す（Undo）

### 実行ルール

#### 即座実行（確認不要）

- **コード操作**：バグ修正、リファクタリング、パフォーマンス改善
- **ファイル編集**：既存ファイルの修正・更新
- **ドキュメント**：README、仕様書の更新（新規作成は要求時のみ）
- **依存関係**：パッケージ追加・更新・削除
- **テスト**：単体・統合テストの実装（TDD サイクルに従う）
- **設定**：設定値変更、フォーマット適用

#### 確認必須

- **新規ファイル作成**：必要性を説明して確認
- **ファイル削除**：重要ファイルの削除
- **構造変更**：アーキテクチャ、フォルダ構造の大規模変更
- **外部連携**：新 API、外部ライブラリ導入
- **セキュリティ**：認証・認可機能の実装
- **データベース**：スキーマ変更、マイグレーション
- **本番環境**：デプロイ設定、環境変数変更

### 実行フロー

```text
1. タスク受信
   ↓
2. 即座実行 or 確認要求を判定
   ↓
3. 実行（既存パターン準拠）
   ↓
4. 完了報告
```

### 作業完了報告のルール

#### 1. 完全完了時の合い言葉

作業が完全に完了し、これ以上継続するタスクがない場合は一語一句違えずに以下を報告する：

```text
May the Force be with you.
```

**使用条件（すべて満たす必要あり）**：

- ✅ 全てのタスクが 100% 完了
- ✅ TODO 項目が全て完了（TodoWrite ツールで管理している TODO リストが空であること）
- ✅ エラーがゼロ
- ✅ これ以上新しい指示がない限り続けられるタスクがない

**禁止事項**：

- ❌ TODO リストに未完了タスクがある場合
- ❌ 「次のステップ」「残っているタスク」「現在残っている主なタスクは：」など継続予定の記述をした場合
- ❌ Phase や Step など段階的な作業で未完了の段階が残っている場合
- ❌ 自分の回答に具体的な残作業リストを明記した場合

#### 2. 部分完了時の報告

作業が部分的に完了し、続きのタスクがある場合は以下のテンプレートを使用：

```markdown
## 実行完了

### 変更内容

- [具体的な変更点]

### 次のステップ

- [推奨される次の作業]
```

#### 継続必要時の動作

合い言葉の条件を満たさない場合：

- 合い言葉は使用しない
- 進捗状況と次のアクションを明示
- 残タスクがある場合は明確に伝える

---

## 開発手法

### TDD サイクル

開発時は Test-Driven Development (TDD) のサイクルに従います：

1. **Red（失敗）**
   - 最もシンプルな失敗するテストを書く
   - テスト名は動作を明確に記述
   - 失敗メッセージが分かりやすいことを確認

2. **Green（成功）**
   - テストを通す最小限のコードを実装
   - この段階では最適化や美しさは考慮しない
   - とにかくテストを通すことに集中

3. **Refactor（改善）**
   - テストが通った後でのみリファクタリング
   - 重複を排除し、意図を明確に
   - 各リファクタリング後にテスト実行

### 変更管理

変更は以下の 2 種類に明確に分離します：

- **構造変更（Structural Changes）**
  - コードの配置・整理・フォーマット
  - 動作は一切変更しない
  - 例：メソッドの並び替え、インポート整理、変数名変更

- **動作変更（Behavioral Changes）**
  - 機能の追加・修正・削除
  - テスト結果が変わる変更
  - 例：新機能追加、バグ修正、ロジック変更

**重要**：構造変更と動作変更を同一コミットに含めない

### コミット規律

コミットは以下の条件をすべて満たした時のみ実行：

- ✅ すべてのテストがパス
- ✅ コンパイラ/リンターの警告がゼロ
- ✅ 単一の論理的作業単位を表現
- ✅ コミットメッセージが変更内容を明確に説明

**推奨事項**：

- 小さく頻繁なコミット
- 各コミットは独立して意味を持つ
- 後から履歴を追いやすい粒度

### リファクタリングルール

リファクタリング時の厳格なルール：

1. **前提条件**
   - すべてのテストが通っている状態でのみ開始
   - 動作変更とリファクタリングを混在させない

2. **実行手順**
   - 確立されたリファクタリングパターンを使用
   - 一度に一つの変更のみ
   - 各ステップ後に必ずテスト実行
   - 失敗したら即座に元に戻す

3. **よく使うパターン**
   - Extract Method（メソッド抽出）
   - Rename（名前変更）
   - Move Method（メソッド移動）
   - Extract Variable（変数抽出）

### 実装アプローチ

効率的な実装のための優先順位：

1. **最初のステップ**
   - 最もシンプルなケースから着手
   - 「動くこと」を最優先
   - 完璧さより進捗を重視

2. **コード品質の原則**
   - 重複を見つけたら即座に排除
   - 意図が明確なコードを書く
   - 依存関係を明示的に
   - メソッドは小さく、単一責任に

3. **段階的な改善**
   - まず動くものを作る
   - テストでカバー
   - その後で最適化

4. **エッジケースの扱い**
   - 基本ケースが動いてから考慮
   - 各エッジケースに対応するテスト追加
   - 段階的に堅牢性を向上

---

## 品質保証

### 設計原則

- 単一責任の原則を遵守
- インターフェースによる疎結合
- 早期リターンで可読性向上
- 過度な抽象化は避ける

### 効率性最適化

- 重複作業の自動排除
- バッチ処理の積極活用
- コンテキストスイッチ最小化

### 一貫性維持

- 既存コードスタイルの自動継承
- プロジェクト規約の自動適用
- 命名規則統一の自動実行

### 自動品質管理

- 変更前後の動作確認実行
- エッジケース考慮の実装
- ドキュメント同期更新

### 冗長性の排除

- 繰り返し処理は必ず関数化
- 共通エラーハンドリングの統一
- ユーティリティ関数の積極活用
- 重複ロジックの即座の抽象化

### ハードコーディング禁止

- マジックナンバーは定数化
- URL、パスは設定ファイルへ
- 環境依存値は環境変数で管理
- ビジネスロジックと設定値の分離

### エラーハンドリング

- 実行不可能時：代替案 3 つ提示
- 部分実行可能時：可能部分を先行実行、残課題を明示

---

## 実行例

- **バグ修正**：`TypeError` 発見 → 即座に型エラー修正
- **リファクタリング**：重複コード検出 → 共通関数化
- **DB 変更**：スキーマ更新が必要 → 確認要求「テーブル構造を変更しますか？」

---

## 継続改善

- 新パターン検出 → 即座に学習・適用
- フィードバック → 次回実行に自動反映
- ベストプラクティス → 随時更新

---

## 制約事項

### Web 検索の制約

- **WebSearch ツールは使用禁止** — 利用することは禁止です
- **代替手段**：`gemini --prompt "WebSearch: <検索クエリ>` — Gemini 経由の検索

---

## 🏗️ プロジェクト構造（Rust + Bevy版）

### Rust実装構成 ✅
```text
negaboku-bevy/
├── src/
│   ├── main.rs                    # エントリポイント・Bevyアプリ起動
│   ├── domain/                    # DDD: ドメイン層（将来実装）
│   │   ├── relationship.rs        # 関係値エンティティ・集約ルート
│   │   ├── battle.rs              # 戦闘ロジック
│   │   └── character.rs           # キャラクター定義
│   ├── application/               # DDD: アプリケーション層（将来実装）
│   │   ├── systems/               # ECSシステム（関係値更新・バトル進行）
│   │   └── services.rs            # ドメイン操作ユースケース
│   ├── infrastructure/            # リソース・ファイルIO（将来実装）
│   │   ├── scenario_loader.rs     # Markdownシナリオ読み込み
│   │   └── asset_manager.rs       # 画像・音楽ハンドル管理
│   └── presentation/              # UI層（将来実装）
│       ├── dialogue_ui.rs         # テキスト・選択肢UI
│       └── battle_ui.rs           # 戦闘UI
├── assets/                        # ゲームアセット
│   ├── scenarios/                 # Markdownシナリオファイル
│   ├── images/                    # 画像リソース
│   └── sounds/                    # 音声リソース
├── Cargo.toml                     # Rust依存関係・プロジェクト設定
├── CLAUDE_BEVY_GUIDELINES.md      # Bevy開発ガイドライン
└── README.md                      # プロジェクト説明
```



## 🛠️ Bevy開発環境（実装完了）

### 即座に実行可能 ✅
```bash
# Rust環境セットアップ
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env

# プロジェクト実行
cd negaboku-bevy
cargo run

# 動作確認済み機能
- タイトル画面表示 ✅
- テキストタイピング効果 ✅
- 背景色切替（Bキー） ✅
- ゲーム状態遷移 ✅
```

### 開発コマンド
```bash
# ホットリロード開発
cargo watch -x run

# テスト実行
cargo test

# コンパイルチェック
cargo check

# Lint・フォーマット（品質チェック）
cargo fmt                  # コードフォーマット
cargo clippy              # 静的解析・lint
cargo clippy --fix        # 自動修正可能な項目を修正

# リリースビルド
cargo build --release
```

### 🛠️ コード品質管理システム

#### Lint・静的解析ツール ✅
- **rustfmt**: コードフォーマット自動化（`rustfmt.toml`設定済み）
- **clippy**: 静的解析・品質チェック（`clippy.toml`設定済み）
- **Cargo.toml**: プロジェクト内lint設定（Bevy特化調整済み）

#### 自動化・CI/CD ✅
- **pre-commit**: コミット前の自動品質チェック（`.pre-commit-config.yaml`）
- **GitHub Actions**: CI/CDパイプライン（`.github/workflows/ci.yml`）
  - Windows・Mac・Linux並列テスト
  - lint・テスト・ビルドの3段階検証
  - リリースアーティファクト自動生成

#### 品質チェックコマンド
```bash
# 手動品質チェック（開発時）
cargo fmt --check          # フォーマット確認
cargo clippy -- -D warnings  # lint（警告をエラー扱い）
cargo test                  # 全テスト実行

# 自動品質チェック（コミット時）
pre-commit install         # 初回セットアップ
pre-commit run --all-files # 全ファイル一括チェック
```

### マルチプラットフォームビルド
```bash
# Bevy標準機能で自動対応
cargo build --release                    # 現在のプラットフォーム
cargo build --release --target x86_64-pc-windows-gnu    # Windows
cargo build --release --target x86_64-apple-darwin      # macOS
cargo build --release --target x86_64-unknown-linux-gnu # Linux
```

## 開発方針

### コード主体・エディタ排除
- **全機能をコードで実装**: シーン構造やNode階層は存在しない
- **ECS（Entity-Component-System）**: データ駆動で状態を管理
- **UI/演出も宣言的コード**: エディタ使用せず、全てRustコードで構築

### 設計優先順位
1. **TDD / テストファースト**: `cargo test`による継続的品質保証
2. **DDD（ドメイン駆動設計）**: ビジネスロジックを中心とした設計
3. **クリーンアーキテクチャ**: 依存方向の明確化
4. **DRY / Tidy First**: 重複排除・整理優先

### ECS原則
- **Entity**: 識別子のみ（データを持たない）
- **Component**: 純粋なデータ構造（ロジックを持たない）
- **System**: Component間のロジック処理
- **Resource**: グローバル状態（シナリオ進行・関係値テーブル等）

## 🛡️ フォント読み込みエラー検知システム（実装済み）

### 概要
フォントファイル読み込みエラーを事前検知し、詳細な対処法を提示するシステムを実装。日本語表示の問題を未然に防ぎます。

### 実装済み対策システム

#### 1. ファイル存在確認（startup時）
```rust
fn setup_fonts(mut commands: Commands, asset_server: Res<AssetServer>) {
    let font_path = "fonts/NotoSansJP-VariableFont_wght.ttf";
    let full_path = format!("assets/{}", font_path);

    if !std::path::Path::new(&full_path).exists() {
        eprintln!("❌ フォントファイルが見つかりません: {}", full_path);
        eprintln!("💡 以下のコマンドでフォントを配置してください:");
        eprintln!("   mkdir -p assets/fonts");
        eprintln!("   cp path/to/NotoSansJP-VariableFont_wght.ttf assets/fonts/");
    }
}
```

#### 2. アセット読み込み状態監視（runtime）
```rust
fn font_loading_system(
    asset_server: Res<AssetServer>,
    fonts: Option<Res<GameFonts>>,
    mut app_state: ResMut<AppState>,
) {
    // LoadState監視: NotLoaded → Loading → Loaded/Failed
    // 段階的な状況表示とエラーハンドリング
}
```

#### 3. デバッグ情報表示（F1キー）
```rust
fn debug_font_system(/* ... */) {
    if keyboard_input.just_pressed(KeyCode::F1) {
        // フォント状態・ハンドル・ファイル存在確認を一括表示
        println!("🔍 ===== デバッグ情報 ===== ");
        // 詳細なデバッグ出力...
    }
}
```

#### 4. 段階的初期化システム
```rust
#[derive(Debug, Default, PartialEq)]
enum InitState {
    LoadingFonts,  // フォント読み込み待機
    FontsReady,    // UI初期化準備完了
    UIReady,       // 通常ゲーム処理
}

fn initialization_system(/* ... */) {
    // フォント準備完了を待ってからUI初期化
    // 確実にフォントが利用可能な状態でUI構築
}
```

### 検知可能なエラー

✅ **フォントファイル未配置**: assets/fontsディレクトリにファイルが存在しない
✅ **アセット読み込み失敗**: Bevyアセットシステムでの読み込みエラー
✅ **初期化タイミング問題**: フォント読み込み前のUI作成を防止
✅ **リソース不正状態**: GameFontsリソースの存在確認

### 使用方法

#### 通常運用
- アプリ起動時に自動でフォント状態をチェック
- エラーがある場合は詳細な修正手順を表示

#### デバッグ時
- **F1キー**: フォント読み込み状態の詳細情報を表示
- **起動ログ**: 段階的な読み込み状況を確認

#### フォント追加・変更時
1. `assets/fonts/`にフォントファイルを配置
2. `setup_fonts`関数でパスを更新
3. 起動時の確認メッセージで成功を確認

### 対応フォント
- **現在**: Noto Sans JP（日本語完全対応）
- **パス**: `assets/fonts/NotoSansJP-VariableFont_wght.ttf`
- **用途**: UI全般（タイトル・メニュー・ダイアログ・ストーリー）

## Claude Code への指示

### 🚨 **最優先遵守項目**
1. **UI層とドメイン層の分離**: ドメインロジックはUIに依存させない
2. **ECSパターン徹底**: Entity/Component/Systemの責務を混在させない
3. **単一機能タスク化**: 1つのPR/Issueにつき1機能実装
4. **テスト駆動開発**: 必ずユニットテストを伴う（`cargo test`で実行可能）
5. **ファイル配置明示**: 生成コードには配置パスと役割を必ず記載

### コード生成フォーマット
```text
## 実装ファイル: src/domain/relationship.rs

[コード内容]

## 配置場所
- ファイルパス: src/domain/relationship.rs
- 役割: 関係値管理のエンティティ・サービス
- 依存: なし（純粋ドメイン層）
```

### テスト戦略
- **Rust標準テスト**: `cargo test`で実行
- **Domain層**: ユニットテスト徹底、UI層は統合テスト中心
- **テストデータ**: 軽量なモックを使用、ファイルIOは避ける

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn relationship_increases_correctly() {
        let mut rel = Relationship::new("souma", "yuzuki");
        rel.modify(25);
        assert_eq!(rel.value(), 25);
        assert_eq!(rel.level(), RelationshipLevel::Normal);
    }
}
```

## 開発プロセス

### 推奨フロー
1. **Issue作成**: 機能単位で分割（例：Markdownパーサー実装）
2. **ブランチ作成**: `feature/機能名`
3. **テスト先行実装**: `cargo test`でレッド→グリーン
4. **実装後レビュー**: CodeRabbit + Claudeによるレビュー
5. **マージ後リファクタ**: Tidy First適用

### ビルド・実行方法
```bash
# 開発用ホットリロード
cargo watch -x run

# テスト実行
cargo test

# リリースビルド
cargo build --release
```

### クロスプラットフォーム対応
- **Bevy標準機能**: Windows・Mac・Linux標準対応
- **モバイル・Web（WASM）**: 将来的に検証予定
- **プラットフォーム固有コード**: 極力避ける

## 開発思想の要約
- **エディタ文化を捨て**: コード主体で統一
- **ECS + DDD + TDD**: 保守性とテスト容易性を両立
- **LLM補助を最大化**: コードが唯一の真実となる構造
- **最小演出**: 爆発・斬撃・光をコードで構築、外部ツール併用は必要時のみ

## 🎯 「願い石と僕たちの絆」実装方針（Rust + Bevy版）

### 設計思想
- **DDD + クリーンアーキテクチャベース**: ドメインロジックを中心とした設計
- **TDD維持**: テスト駆動開発による品質保証
- **ECS文化の採用**: Bevy標準のEntity-Component-Systemモデル
- **型安全性重視**: Rustの所有権システムによる実行時エラー防止

### 開発優先順位
1. **骨子とテキスト優先**: ゲームの核となるシステム・ストーリーを最優先
2. **UIや演出は後回し**: 基本機能の実装完了後に視覚的要素を追加
3. **クロスプラットフォーム想定**: 最初はWindows優先、後にMac・Linux対応
4. **段階的実装**: 体験版 → DLC → 完全版の段階的リリース

### アセット・リソース方針
- **エフェクト・BGM**: 無料素材加工ベースで統一
- **イラスト**: 男女別絵師で統一感を確保
- **テキスト**: 日本語優先、将来的な多言語対応も視野
- **データ管理**: Bevy Assetシステム活用でデータ駆動設計

### キャラクター・ストーリー実装
- **メインキャラクター**: ソウマ、ユズキ、レツジ、カイ等の実装
- **推奨ペア**: 専用イベント・エンディング・カットイン有りの特別ルート
- **関係値システム**: 3段階（対立/通常/親密）による戦闘・イベント分岐
- **願い石ストーリー**: AIリラとの対峙を核とした物語展開

### 🔧 Bevy実装方針

#### Component設計原則
```rust
// ✅ 推奨: 純粋なデータ構造
#[derive(Component)]
pub struct DialogueText {
    pub full_text: String,
    pub current_char: usize,
    pub is_complete: bool,
}

// ❌ 避ける: ロジックを含むComponent
#[derive(Component)]
pub struct BadComponent {
    pub data: String,
    // ロジックメソッドは別のSystemで処理
}
```

#### System設計原則
```rust
// ✅ 推奨: 単一責務のSystem
pub fn text_typing_system(
    mut query: Query<(&mut DialogueText, &mut Text2d)>,
    time: Res<Time>,
) {
    // テキストタイピング処理のみ
}

// ✅ 推奨: Resource活用
#[derive(Resource)]
pub struct GameState {
    pub current_scene: String,
    pub is_story_mode: bool,
}
```

---

このプロジェクトは **Rust + Bevy ECS** を活用し、「僕たちの絆」を紡ぐ3段階関係値システムを核とした革新的なRPG体験の創造を目指します。**型安全性・高速実行・クロスプラットフォーム**対応を標準実装し、**Windows・Mac・Linux**での統一されたゲーム体験を提供します。

---

## ライセンス

このプロジェクトは **Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)** の下でライセンスされています。詳細はリポジトリルートの `LICENSE` ファイルを参照してください。